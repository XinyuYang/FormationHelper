{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Animate the drawing of the wave\n */\n\n\nvar animateWave = function animateWave(ctx, bounds, style, maxAmp) {\n  var scaleFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n  if (scaleFactor <= 100) {\n    setTimeout(function () {\n      requestAnimationFrame(function () {\n        return drawPoints(ctx, bounds, style, maxAmp, scaleFactor / 100);\n      });\n      animateWave(ctx, bounds, style, maxAmp, scaleFactor + 1);\n    }, 1);\n  }\n};\n/**\n * Calculate all wave data points\n */\n\n\nvar calculateWaveData = exports.calculateWaveData = function calculateWaveData(buffer, width, pointWidth) {\n  if (!buffer) return []; // get the wave data\n\n  var wave = buffer.getChannelData(0);\n  var pointCnt = width / pointWidth; // find how many steps we are going to draw\n\n  var step = Math.ceil(wave.length / pointCnt); // Get array of bounds of each step\n\n  return getBoundArray(wave, pointCnt, step);\n};\n/**\n * Convienence function to draw a point in waveform\n */\n\n\nvar drawPoint = function drawPoint(ctx, x, y, width, height) {\n  ctx.fillRect(x, y, width, height);\n};\n/**\n * Draw all the points in the wave\n */\n\n\nvar drawPoints = function drawPoints(ctx, bounds, style, maxAmp) {\n  var scaleFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  bounds.forEach(function (bound, i) {\n    drawPoint(ctx, i * style.pointWidth, (1 + bound.min) * maxAmp, style.pointWidth, Math.max(1, (bound.max - bound.min) * maxAmp) * scaleFactor);\n  });\n};\n/**\n * Draw a waveform on a canvas\n * buffer - waveform buffer\n * canvas - HTML5 canvas reference\n * style - line style to use (color)\n */\n\n\nvar drawWaveform = exports.drawWaveform = function drawWaveform(bounds, canvas, markerStyle) {\n  var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  var waveStyle = arguments[4];\n  var height = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 300;\n  var width = arguments[6];\n  if (!canvas || !bounds || !bounds.length) return;\n  var ctx = canvas.getContext('2d'); // clear the canvas\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height); // get our canvas size\n\n  var canvasSize = {\n    height: canvas.height = height,\n    width: canvas.width = width\n  }; // set up line style\n\n  ctx.fillStyle = waveStyle.color; // find the max height we can draw\n\n  var maxAmp = canvasSize.height / 2;\n\n  if (waveStyle.animate) {\n    animateWave(ctx, bounds, waveStyle, maxAmp, 1);\n  } else {\n    drawPoints(ctx, bounds, waveStyle, maxAmp);\n  }\n};\n/**\n * Calculate the bounds of each step in the buffer\n */\n\n\nvar getBoundArray = function getBoundArray(wave, pointCnt, step) {\n  var bounds = [];\n\n  for (var i = 0; i < pointCnt; i++) {\n    // get the max and min values at this step\n    bounds = [].concat(_toConsumableArray(bounds), [getBounds(wave.slice(i * step, i * step + step))]);\n  }\n\n  return bounds;\n};\n/**\n * Get the max and min values of an array\n */\n\n\nvar getBounds = function getBounds(values) {\n  return values.reduce(function (total, v) {\n    return {\n      max: v > total.max ? v : total.max,\n      min: v < total.min ? v : total.min\n    };\n  }, {\n    max: -1.0,\n    min: 1.0\n  });\n};","map":null,"metadata":{},"sourceType":"script"}