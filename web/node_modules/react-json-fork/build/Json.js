/*
react-json-fork v0.0.1
https://github.com/arqex/react-json
MIT: https://github.com/arqex/react-json/raw/master/LICENSE
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require(undefined));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Json"] = factory(require(undefined));
	else
		root["Json"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tFreezer = __webpack_require__(2),\r\n\tobjectAssign = __webpack_require__(8),\r\n\tTypeField = __webpack_require__(9),\r\n\tObjectField = __webpack_require__(11),\r\n\tArrayField = __webpack_require__(16),\r\n\tStringField = __webpack_require__(17),\r\n\tBooleanField = __webpack_require__(19),\r\n\tNumberField = __webpack_require__(20),\r\n\tTextField = __webpack_require__(21),\r\n\tPasswordField = __webpack_require__(22),\r\n\tSelectField = __webpack_require__(23),\r\n\tdeepSettings = __webpack_require__(10)\r\n;\r\n\r\n// Detect flexbox support\r\nvar flexboxClass = typeof document != 'undefined' || '',\r\n\tcss\r\n;\r\nif( flexboxClass ){\r\n\tcss = document.documentElement.style;\r\n\tif( ('flexWrap' in css) || ('webkitFlexWrap' in css) || ('msFlexWrap' in css) )\r\n\t\tflexboxClass = ' jsonFlex';\r\n}\r\n\r\n\r\n\r\n/**\r\n * The main component. It will refresh the props when the store changes.\r\n *\r\n * @prop  {Object|FreezerNode} value The JSON object, value of the form.\r\n * @prop  {Object} settings Customization settings\r\n */\r\nvar Json = React.createClass({\r\n\r\n\tgetDefaultProps: function(){\r\n\t\treturn {\r\n\t\t\tvalue: {},\r\n\t\t\tbinding:{},\r\n\t\t\terrors: false,\r\n\t\t\tupdating: false\r\n\t\t};\r\n\t},\r\n\r\n\tchildContextTypes: {\r\n\t\ttypeDefaults: React.PropTypes.object\r\n\t},\r\n\r\n\tgetChildContext: function(){\r\n\t\treturn {\r\n\t\t\ttypeDefaults: this.state.defaults\r\n\t\t};\r\n\t},\r\n\r\n\tgetInitialState: function(){\r\n\t\tvar me = this,\r\n\t\t\tvalue = this.props.value,\r\n\t\t\tbinding = this.props.binding,\r\n\t\t\tlistener\r\n\t\t;\r\n\r\n\t\t// If it is a freezer node\r\n\t\tif( !value.getListener )\r\n\t\t\tvalue = new Freezer( value ).get();\r\n\r\n\t\t// Listen to changes\r\n\t\tvalue.getListener().on('update', function( updated ){\r\n\t\t\tif( me.state.updating )\r\n\t\t\t\treturn me.setState({ updating: false });\r\n\r\n\t\t\tif (me.state.value === updated) return;\r\n\t\t\tme.setState({value: updated});\r\n\r\n\r\n\t\t\tif( me.state.errors )\r\n\t\t\t\tme.getValidationErrors();\r\n\r\n\t\t\tif( me.props.onChange )\r\n\t\t\t\tme.props.onChange( updated.toJS() );\r\n\t\t});\r\n\r\n\r\n\r\n\t\t// If it is a freezer node\r\n\t\tif( !binding.getListener )\r\n\t\t\tbinding = new Freezer( binding ).get();\r\n\r\n\t\t// Listen to changes\r\n\t\tbinding.getListener().on('update', function( updated ){\r\n\t\t\tif (me.state.binding === updated) return;\r\n\r\n\t\t\tme.setState({binding: updated});\r\n\r\n\r\n\t\t\tif( me.props.onBindingChange )\r\n\t\t\t\tme.props.onBindingChange( updated.toJS() );\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\tvalue: value,\r\n\t\t\tbinding:binding,\r\n\t\t\tdefaults: this.createDefaults(),\r\n\t\t\tid: this.getId()\r\n\t\t};\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( newProps ){\r\n\t\tif( !newProps.value.getListener || !newProps.binding.getListener){\r\n\t\t\tthis.setState({\r\n\t\t\t\tupdating: true,\r\n\t\t\t\tvalue: this.state.value.reset( newProps.value ),\r\n\t\t\t\tbinding: this.state.binding.reset( newProps.binding )\r\n\t\t\t});\r\n\t\t}\r\n\t\tthis.setState( {defaults: this.createDefaults()} );\r\n\t},\r\n\r\n\trender: function(){\r\n\t\tvar settings = this.props.settings || {},\r\n\t\t\tob = React.createElement( TypeField, {\r\n\t\t\t\ttype: 'object',\r\n\t\t\t\tvalue: this.state.value,\r\n\t\t\t\tbinding:this.state.binding,\r\n\t\t\t\tsettings: objectAssign( {}, this.state.defaults.object, {\r\n\t\t\t\t\tfields: settings.fields,\r\n\t\t\t\t\tuseBinding: settings.useBinding,\r\n\t\t\t\t\tediting: this.getFormSetting( settings, 'editing', 'always'),\r\n\t\t\t\t\tfixedFields: this.getFormSetting( settings, 'fixedFields', true),\r\n\t\t\t\t\tadder:  this.getFormSetting( settings, 'adder', false),\r\n\t\t\t\t\thiddenFields: settings.hiddenFields,\r\n\t\t\t\t\theader: false,\r\n\t\t\t\t\torder: settings.order\r\n\t\t\t\t}),\r\n\t\t\t\tref: 'value',\r\n\t\t\t\tdefaults: this.state.defaults,\r\n\t\t\t\tid: this.state.id\r\n\t\t\t}),\r\n\t\t\tclassName = 'jsonEditor' + flexboxClass\r\n\t\t;\r\n\r\n\t\treturn React.DOM.div({ className: className }, ob);\r\n\t},\r\n\r\n\tgetValue: function(){\r\n\t\treturn this.state.value.toJS();\r\n\t},\r\n\tgetBinding:function(){\r\n\t\treturn this.state.binding.toJS();\r\n\t},\r\n\r\n\tgetValidationErrors: function(){\r\n\t\tvar jsonValue = this.getValue(),\r\n\t\t\terrors = this.refs.value.getValidationErrors( jsonValue )\r\n\t\t;\r\n\r\n\t\tthis.setState( {errors: errors.length} );\r\n\t\treturn errors.length ? errors : false;\r\n\t},\r\n\tgetDeepSettings: function(){\r\n\t\tvar settings = {};\r\n\r\n\t\tfor( var key in deepSettings ){\r\n\t\t\tsettings[ key ] = deepSettings[ key ]( this, settings[key] );\r\n\t\t}\r\n\r\n\t\treturn settings;\r\n\t},\r\n\tcreateDefaults: function(){\r\n\t\tvar settings = this.props.settings || {},\r\n\t\t\tcomponents = TypeField.prototype.components,\r\n\t\t\tpropDefaults = settings.defaults || {},\r\n\t\t\tdefaults = {}\r\n\t\t;\r\n\r\n\t\tfor( var type in components ){\r\n\t\t\tdefaults[ type ] = objectAssign( {}, components[ type ].prototype.defaults || {}, propDefaults[ type ] || {});\r\n\t\t}\r\n\r\n\t\treturn defaults;\r\n\t},\r\n\r\n\tgetId: function(){\r\n\t\treturn btoa( parseInt( Math.random() * 10000 ) ).replace(/=/g, '');\r\n\t},\r\n\r\n\tgetFormSetting: function( settings, field, def ){\r\n\t\tif( typeof settings[ field ] != 'undefined' )\r\n\t\t\treturn settings[ field ];\r\n\t\tif( settings.form )\r\n\t\t\treturn def;\r\n\t}\r\n});\r\n\r\n// Add global modifier functions\r\nJson.registerType = TypeField.registerType.bind( TypeField );\r\n\r\n// Register basic types\r\nJson.registerType( 'object', ObjectField );\r\nJson.registerType( 'array', ArrayField, true );\r\nJson.registerType( 'string', StringField, true );\r\nJson.registerType( 'text', TextField, true );\r\nJson.registerType( 'number', NumberField, true );\r\nJson.registerType( 'boolean', BooleanField, true );\r\nJson.registerType( 'password', PasswordField );\r\nJson.registerType( 'select', SelectField );\r\n\r\nmodule.exports = Json;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Json.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./Json.js?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\"}\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22%7D?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Freezer = __webpack_require__(3);\nmodule.exports = Freezer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/freezer.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/freezer.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar Utils = __webpack_require__( 4 ),\r\n\tEmitter = __webpack_require__( 5 ),\r\n\tMixins = __webpack_require__( 6 ),\r\n\tFrozen = __webpack_require__( 7 )\r\n;\r\n\r\n//#build\r\nvar Freezer = function( initialValue, options ) {\r\n\tvar me = this,\r\n\t\tmutable = ( options && options.mutable ) || false,\r\n\t\tlive = ( options && options.live ) || live\r\n\t;\r\n\r\n\t// Immutable data\r\n\tvar frozen;\r\n\tvar pivotTriggers = [], pivotTicking = 0;\r\n\tvar triggerNow = function( node ){\r\n\t\tvar _ = node.__,\r\n\t\t\ti\r\n\t\t;\r\n\t\tif( _.listener ){\r\n\t\t\tFrozen.trigger( node, 'update', 0, true );\r\n\r\n\t\t\tif( !_.parents.length )\r\n\t\t\t\t_.listener.trigger('immediate', 'now');\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < _.parents.length; i++) {\r\n\t\t\tnotify('now', _.parents[i]);\r\n\t\t}\r\n\t};\r\n\tvar addToPivotTriggers = function( node ){\r\n\t\tpivotTriggers.push( node );\r\n\t\tif( !pivotTicking ){\r\n\t\t\tpivotTicking = 1;\r\n\t\t\tUtils.nextTick( function(){\r\n\t\t\t\tpivotTriggers = [];\r\n\t\t\t\tpivotTicking = 0;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tvar notify = function notify( eventName, node, options ){\r\n\t\tvar _ = node.__,\r\n\t\t\tnowNode\r\n\t\t;\r\n\r\n\t\tif( eventName == 'listener' )\r\n\t\t\treturn Frozen.createListener( node );\r\n\r\n\t\tif( eventName == 'now' ){\r\n\t\t\tif( pivotTriggers.length ){\r\n\t\t\t\twhile( pivotTriggers.length ){\r\n\t\t\t\t\tnowNode = pivotTriggers.shift();\r\n\t\t\t\t\ttriggerNow( nowNode );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttriggerNow( node );\r\n\t\t\t}\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar update = Frozen.update( eventName, node, options );\r\n\r\n\t\tif( eventName != 'pivot' ){\r\n\t\t\tvar pivot = Utils.findPivot( update );\r\n\t\t\tif( pivot ) {\r\n\t\t\t\taddToPivotTriggers( update );\r\n\t  \t\t\treturn pivot;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn update;\r\n\t};\r\n\r\n\tvar freeze = function(){};\r\n\tif( !mutable )\r\n\t\tfreeze = function( obj ){ Object.freeze( obj ); };\r\n\r\n\t// Create the frozen object\r\n\tfrozen = Frozen.freeze( initialValue, notify, freeze, live );\r\n\r\n\t// Listen to its changes immediately\r\n\tvar listener = frozen.getListener();\r\n\r\n\t// Updating flag to trigger the event on nextTick\r\n\tvar updating = false;\r\n\r\n\tlistener.on( 'immediate', function( prevNode, updated ){\r\n\r\n\t\tif( prevNode == 'now' ){\r\n\t\t\tif( !updating )\r\n\t\t\t\treturn;\r\n\t\t\tupdating = false;\r\n\t\t\treturn me.trigger( 'update', frozen );\r\n\t\t}\r\n\r\n\t\tif( prevNode != frozen )\r\n\t\t\treturn;\r\n\r\n\t\tfrozen = updated;\r\n\r\n\t\tif( live )\r\n\t\t\treturn me.trigger( 'update', updated );\r\n\r\n\t\t// Trigger on next tick\r\n\t\tif( !updating ){\r\n\t\t\tupdating = true;\r\n\t\t\tUtils.nextTick( function(){\r\n\t\t\t\tif( updating ){\r\n\t\t\t\t\tupdating = false;\r\n\t\t\t\t\tme.trigger( 'update', frozen );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n\tUtils.addNE( this, {\r\n\t\tget: function(){\r\n\t\t\treturn frozen;\r\n\t\t},\r\n\t\tset: function( node ){\r\n\t\t\tvar newNode = notify( 'reset', frozen, node );\r\n\t\t\tnewNode.__.listener.trigger( 'immediate', frozen, newNode );\r\n\t\t}\r\n\t});\r\n\r\n\tUtils.addNE( this, { getData: this.get, setData: this.set } );\r\n\r\n\t// The event store\r\n\tthis._events = [];\r\n}\r\n\r\nFreezer.prototype = Utils.createNonEnumerable({constructor: Freezer}, Emitter);\r\n//#build\r\n\r\nmodule.exports = Freezer;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/src/freezer.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/src/freezer.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("'use strict';\r\n\r\n//#build\r\nvar global = (new Function(\"return this\")());\r\n\r\nvar Utils = {\r\n\textend: function( ob, props ){\r\n\t\tfor( var p in props ){\r\n\t\t\tob[p] = props[p];\r\n\t\t}\r\n\t\treturn ob;\r\n\t},\r\n\r\n\tcreateNonEnumerable: function( obj, proto ){\r\n\t\tvar ne = {};\r\n\t\tfor( var key in obj )\r\n\t\t\tne[key] = {value: obj[key] };\r\n\t\treturn Object.create( proto || {}, ne );\r\n\t},\r\n\r\n\terror: function( message ){\r\n\t\tvar err = new Error( message );\r\n\t\tif( console )\r\n\t\t\treturn console.error( err );\r\n\t\telse\r\n\t\t\tthrow err;\r\n\t},\r\n\r\n\teach: function( o, clbk ){\r\n\t\tvar i,l,keys;\r\n\t\tif( o && o.constructor == Array ){\r\n\t\t\tfor (i = 0, l = o.length; i < l; i++)\r\n\t\t\t\tclbk( o[i], i );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tkeys = Object.keys( o );\r\n\t\t\tfor( i = 0, l = keys.length; i < l; i++ )\r\n\t\t\t\tclbk( o[ keys[i] ], keys[i] );\r\n\t\t}\r\n\t},\r\n\r\n\taddNE: function( node, attrs ){\r\n\t\tfor( var key in attrs ){\r\n\t\t\tObject.defineProperty( node, key, {\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: attrs[ key ]\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t// nextTick - by stagas / public domain\r\n  \tnextTick: (function () {\r\n      var queue = [],\r\n\t\t\tdirty = false,\r\n\t\t\tfn,\r\n\t\t\thasPostMessage = !!global.postMessage,\r\n\t\t\tmessageName = 'nexttick',\r\n\t\t\ttrigger = (function () {\r\n\t\t\t\treturn hasPostMessage\r\n\t\t\t\t\t? function trigger () {\r\n\t\t\t\t\tglobal.postMessage(messageName, '*');\r\n\t\t\t\t}\r\n\t\t\t\t: function trigger () {\r\n\t\t\t\t\tsetTimeout(function () { processQueue() }, 0);\r\n\t\t\t\t};\r\n\t\t\t}()),\r\n\t\t\tprocessQueue = (function () {\r\n\t\t\t\treturn hasPostMessage\r\n\t\t\t\t\t? function processQueue (event) {\r\n\t\t\t\t\t\tif (event.source === global && event.data === messageName) {\r\n\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t\tflushQueue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t: flushQueue;\r\n      \t})()\r\n      ;\r\n\r\n      function flushQueue () {\r\n          while (fn = queue.shift()) {\r\n              fn();\r\n          }\r\n          dirty = false;\r\n      }\r\n\r\n      function nextTick (fn) {\r\n          queue.push(fn);\r\n          if (dirty) return;\r\n          dirty = true;\r\n          trigger();\r\n      }\r\n\r\n      if (hasPostMessage) global.addEventListener('message', processQueue, true);\r\n\r\n      nextTick.removeListener = function () {\r\n          global.removeEventListener('message', processQueue, true);\r\n      }\r\n\r\n      return nextTick;\r\n  })(),\r\n\r\n  findPivot: function( node ){\r\n  \t\tif( !node || !node.__ )\r\n  \t\t\treturn;\r\n\r\n  \t\tif( node.__.pivot )\r\n  \t\t\treturn node;\r\n\r\n  \t\tvar found = 0,\r\n  \t\t\tparents = node.__.parents,\r\n  \t\t\ti = 0,\r\n  \t\t\tparent\r\n  \t\t;\r\n\r\n  \t\t// Look up for the pivot in the parents\r\n  \t\twhile( !found && i < parents.length ){\r\n  \t\t\tparent = parents[i];\r\n  \t\t\tif( parent.__.pivot )\r\n  \t\t\t\tfound = parent;\r\n  \t\t\ti++;\r\n  \t\t}\r\n\r\n  \t\tif( found ){\r\n  \t\t\treturn found;\r\n  \t\t}\r\n\r\n  \t\t// If not found, try with the parent's parents\r\n  \t\ti=0;\r\n  \t\twhile( !found && i < parents.length ){\r\n\t  \t\tfound = this.findPivot( parents[i] );\r\n\t  \t\ti++;\r\n\t  \t}\r\n\r\n  \t\treturn found;\r\n  }\r\n};\r\n//#build\r\n\r\n\r\nmodule.exports = Utils;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/src/utils.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/src/utils.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar Utils = __webpack_require__( 4 );\r\n\r\n//#build\r\n\r\n// The prototype methods are stored in a different object\r\n// and applied as non enumerable properties later\r\nvar emitterProto = {\r\n\ton: function( eventName, listener, once ){\r\n\t\tvar listeners = this._events[ eventName ] || [];\r\n\r\n\t\tlisteners.push({ callback: listener, once: once});\r\n\t\tthis._events[ eventName ] =  listeners;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonce: function( eventName, listener ){\r\n\t\tthis.on( eventName, listener, true );\r\n\t},\r\n\r\n\toff: function( eventName, listener ){\r\n\t\tif( typeof eventName == 'undefined' ){\r\n\t\t\tthis._events = {};\r\n\t\t}\r\n\t\telse if( typeof listener == 'undefined' ) {\r\n\t\t\tthis._events[ eventName ] = [];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar listeners = this._events[ eventName ] || [],\r\n\t\t\t\ti\r\n\t\t\t;\r\n\r\n\t\t\tfor (i = listeners.length - 1; i >= 0; i--) {\r\n\t\t\t\tif( listeners[i].callback === listener )\r\n\t\t\t\t\tlisteners.splice( i, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttrigger: function( eventName ){\r\n\t\tvar args = [].slice.call( arguments, 1 ),\r\n\t\t\tlisteners = this._events[ eventName ] || [],\r\n\t\t\tonceListeners = [],\r\n\t\t\ti, listener\r\n\t\t;\r\n\r\n\t\t// Call listeners\r\n\t\tfor (i = 0; i < listeners.length; i++) {\r\n\t\t\tlistener = listeners[i];\r\n\r\n\t\t\tif( listener.callback )\r\n\t\t\t\tlistener.callback.apply( null, args );\r\n\t\t\telse {\r\n\t\t\t\t// If there is not a callback, remove!\r\n\t\t\t\tlistener.once = true;\r\n\t\t\t}\r\n\r\n\t\t\tif( listener.once )\r\n\t\t\t\tonceListeners.push( i );\r\n\t\t}\r\n\r\n\t\t// Remove listeners marked as once\r\n\t\tfor( i = onceListeners.length - 1; i >= 0; i-- ){\r\n\t\t\tlisteners.splice( onceListeners[i], 1 );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\n// Methods are not enumerable so, when the stores are\r\n// extended with the emitter, they can be iterated as\r\n// hashmaps\r\nvar Emitter = Utils.createNonEnumerable( emitterProto );\r\n//#build\r\n\r\nmodule.exports = Emitter;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/src/emitter.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/src/emitter.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar Utils = __webpack_require__( 4 );\r\n\r\n//#build\r\n\r\n/**\r\n * Creates non-enumerable property descriptors, to be used by Object.create.\r\n * @param  {Object} attrs Properties to create descriptors\r\n * @return {Object}       A hash with the descriptors.\r\n */\r\nvar createNE = function( attrs ){\r\n\tvar ne = {};\r\n\r\n\tfor( var key in attrs ){\r\n\t\tne[ key ] = {\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: attrs[ key]\r\n\t\t}\r\n\t}\r\n\r\n\treturn ne;\r\n}\r\n\r\nvar commonMethods = {\r\n\tset: function( attr, value ){\r\n\t\tvar attrs = attr,\r\n\t\t\tupdate = this.__.trans\r\n\t\t;\r\n\r\n\t\tif( typeof attr == 'string' ){\r\n\t\t\tattrs = {};\r\n\t\t\tattrs[ attr ] = value;\r\n\t\t}\r\n\r\n\t\tif( !update ){\r\n\t\t\tfor( var key in attrs ){\r\n\t\t\t\tupdate = update || this[ key ] != attrs[ key ];\r\n\t\t\t}\r\n\r\n\t\t\t// No changes, just return the node\r\n\t\t\tif( !update )\r\n\t\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\treturn this.__.notify( 'merge', this, attrs );\r\n\t},\r\n\r\n\treset: function( attrs ) {\r\n\t\treturn this.__.notify( 'replace', this, attrs );\r\n\t},\r\n\r\n\tgetListener: function(){\r\n\t\treturn this.__.notify( 'listener', this );\r\n\t},\r\n\r\n\ttoJS: function(){\r\n\t\tvar js;\r\n\t\tif( this.constructor == Array ){\r\n\t\t\tjs = new Array( this.length );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tjs = {};\r\n\t\t}\r\n\r\n\t\tUtils.each( this, function( child, i ){\r\n\t\t\tif( child && child.__ )\r\n\t\t\t\tjs[ i ] = child.toJS();\r\n\t\t\telse\r\n\t\t\t\tjs[ i ] = child;\r\n\t\t});\r\n\r\n\t\treturn js;\r\n\t},\r\n\r\n\ttransact: function(){\r\n\t\treturn this.__.notify( 'transact', this );\r\n\t},\r\n\r\n\trun: function(){\r\n\t\treturn this.__.notify( 'run', this );\r\n\t},\r\n\r\n\tnow: function(){\r\n\t\treturn this.__.notify( 'now', this );\r\n\t},\r\n\r\n\tpivot: function(){\r\n\t\treturn this.__.notify( 'pivot', this );\r\n\t}\r\n};\r\n\r\nvar arrayMethods = Utils.extend({\r\n\tpush: function( el ){\r\n\t\treturn this.append( [el] );\r\n\t},\r\n\r\n\tappend: function( els ){\r\n\t\tif( els && els.length )\r\n\t\t\treturn this.__.notify( 'splice', this, [this.length, 0].concat( els ) );\r\n\t\treturn this;\r\n\t},\r\n\r\n\tpop: function(){\r\n\t\tif( !this.length )\r\n\t\t\treturn this;\r\n\r\n\t\treturn this.__.notify( 'splice', this, [this.length -1, 1] );\r\n\t},\r\n\r\n\tunshift: function( el ){\r\n\t\treturn this.prepend( [el] );\r\n\t},\r\n\r\n\tprepend: function( els ){\r\n\t\tif( els && els.length )\r\n\t\t\treturn this.__.notify( 'splice', this, [0, 0].concat( els ) );\r\n\t\treturn this;\r\n\t},\r\n\r\n\tshift: function(){\r\n\t\tif( !this.length )\r\n\t\t\treturn this;\r\n\r\n\t\treturn this.__.notify( 'splice', this, [0, 1] );\r\n\t},\r\n\r\n\tsplice: function( index, toRemove, toAdd ){\r\n\t\treturn this.__.notify( 'splice', this, arguments );\r\n\t}\r\n}, commonMethods );\r\n\r\nvar FrozenArray = Object.create( Array.prototype, createNE( arrayMethods ) );\r\n\r\nvar Mixins = {\r\n\r\nHash: Object.create( Object.prototype, createNE( Utils.extend({\r\n\tremove: function( keys ){\r\n\t\tvar filtered = [],\r\n\t\t\tk = keys\r\n\t\t;\r\n\r\n\t\tif( keys.constructor != Array )\r\n\t\t\tk = [ keys ];\r\n\r\n\t\tfor( var i = 0, l = k.length; i<l; i++ ){\r\n\t\t\tif( this.hasOwnProperty( k[i] ) )\r\n\t\t\t\tfiltered.push( k[i] );\r\n\t\t}\r\n\r\n\t\tif( filtered.length )\r\n\t\t\treturn this.__.notify( 'remove', this, filtered );\r\n\t\treturn this;\r\n\t}\r\n}, commonMethods))),\r\n\r\nList: FrozenArray,\r\narrayMethods: arrayMethods\r\n};\r\n//#build\r\n\r\nmodule.exports = Mixins;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/src/mixins.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/src/mixins.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar Utils = __webpack_require__( 4 ),\r\n\tMixins = __webpack_require__( 6),\r\n\tEmitter = __webpack_require__(5)\r\n;\r\n\r\n//#build\r\nvar Frozen = {\r\n\tfreeze: function( node, notify, freezeFn, live ){\r\n\t\tif( node && node.__ ){\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar me = this,\r\n\t\t\tfrozen, mixin, cons\r\n\t\t;\r\n\r\n\t\tif( node.constructor == Array ){\r\n\t\t\tfrozen = this.createArray( node.length );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfrozen = Object.create( Mixins.Hash );\r\n\t\t}\r\n\r\n\t\tUtils.addNE( frozen, { __: {\r\n\t\t\tlistener: false,\r\n\t\t\tparents: [],\r\n\t\t\tnotify: notify,\r\n\t\t\tdirty: false,\r\n\t\t\tfreezeFn: freezeFn,\r\n\t\t\tlive: live || false\r\n\t\t}});\r\n\r\n\t\t// Freeze children\r\n\t\tUtils.each( node, function( child, key ){\r\n\t\t\tcons = child && child.constructor;\r\n\t\t\tif( cons == Array || cons == Object ){\r\n\t\t\t\tchild = me.freeze( child, notify, freezeFn, live );\r\n\t\t\t}\r\n\r\n\t\t\tif( child && child.__ ){\r\n\t\t\t\tme.addParent( child, frozen );\r\n\t\t\t}\r\n\r\n\t\t\tfrozen[ key ] = child;\r\n\t\t});\r\n\r\n\t\tfreezeFn( frozen );\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\tupdate: function( type, node, options ){\r\n\t\tif( !this[ type ])\r\n\t\t\treturn Utils.error( 'Unknown update type: ' + type );\r\n\r\n\t\treturn this[ type ]( node, options );\r\n\t},\r\n\r\n\treset: function( node, value ){\r\n\t\tvar me = this,\r\n\t\t\t_ = node.__,\r\n\t\t\tfrozen\r\n\t\t;\r\n\r\n\t\tif( value && value.__ ){\r\n\t\t\tfrozen = value;\r\n\t\t\tfrozen.__.listener = value.__.listener;\r\n\t\t\tfrozen.__.parents = [];\r\n\r\n\t\t\t// Set back the parent on the children\r\n\t\t\t// that have been updated\r\n\t\t\tthis.fixChildren( frozen, node );\r\n\t\t\tUtils.each( frozen, function( child ){\r\n\t\t\t\tif( child && child.__ ){\r\n\t\t\t\t\tme.removeParent( node );\r\n\t\t\t\t\tme.addParent( child, frozen );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfrozen = this.freeze( node, _.notify, _.freezeFn, _.live );\r\n\t\t}\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\tmerge: function( node, attrs ){\r\n\t\tvar _ = node.__,\r\n\t\t\ttrans = _.trans,\r\n\r\n\t\t\t// Clone the attrs to not modify the argument\r\n\t\t\tattrs = Utils.extend( {}, attrs)\r\n\t\t;\r\n\r\n\t\tif( trans ){\r\n\r\n\t\t\tfor( var attr in attrs )\r\n\t\t\t\ttrans[ attr ] = attrs[ attr ];\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar me = this,\r\n\t\t\tfrozen = this.copyMeta( node ),\r\n\t\t\tnotify = _.notify,\r\n\t\t\tval, cons, key, isFrozen\r\n\t\t;\r\n\r\n\t\tUtils.each( node, function( child, key ){\r\n\t\t\tisFrozen = child && child.__;\r\n\r\n\t\t\tif( isFrozen ){\r\n\t\t\t\tme.removeParent( child, node );\r\n\t\t\t}\r\n\r\n\t\t\tval = attrs[ key ];\r\n\t\t\tif( !val ){\r\n\t\t\t\tif( isFrozen )\r\n\t\t\t\t\tme.addParent( child, frozen );\r\n\t\t\t\treturn frozen[ key ] = child;\r\n\t\t\t}\r\n\r\n\t\t\tcons = val && val.constructor;\r\n\r\n\t\t\tif( cons == Array || cons == Object )\r\n\t\t\t\tval = me.freeze( val, notify, _.freezeFn, _.live );\r\n\r\n\t\t\tif( val && val.__ )\r\n\t\t\t\tme.addParent( val, frozen );\r\n\r\n\t\t\tdelete attrs[ key ];\r\n\r\n\t\t\tfrozen[ key ] = val;\r\n\t\t});\r\n\r\n\r\n\t\tfor( key in attrs ) {\r\n\t\t\tval = attrs[ key ];\r\n\t\t\tcons = val && val.constructor;\r\n\r\n\t\t\tif( cons == Array || cons == Object )\r\n\t\t\t\tval = me.freeze( val, notify, _.freezeFn, _.live );\r\n\r\n\t\t\tif( val && val.__ )\r\n\t\t\t\tme.addParent( val, frozen );\r\n\r\n\t\t\tfrozen[ key ] = val;\r\n\t\t}\r\n\r\n\t\t_.freezeFn( frozen );\r\n\r\n\t\tthis.refreshParents( node, frozen );\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\treplace: function( node, replacement ) {\r\n\r\n\t\tvar me = this,\r\n\t\t\tcons = replacement && replacement.constructor,\r\n\t\t\t_ = node.__,\r\n\t\t\tfrozen = replacement\r\n\t\t;\r\n\r\n\t\tif( cons == Array || cons == Object ) {\r\n\r\n\t\t\tfrozen = me.freeze( replacement, _.notify, _.freezeFn, _.live );\r\n\r\n\t\t\tfrozen.__.parents = _.parents;\r\n\r\n\t\t\t// Add the current listener if exists, replacing a\r\n\t\t\t// previous listener in the frozen if existed\r\n\t\t\tif( _.listener )\r\n\t\t\t\tfrozen.__.listener = _.listener;\r\n\r\n\t\t\t// Since the parents will be refreshed directly,\r\n\t\t\t// Trigger the listener here\r\n\t\t\tif( frozen.__.listener )\r\n\t\t\t\tthis.trigger( frozen, 'update', frozen, _.live );\r\n\t\t}\r\n\r\n\t\t// Refresh the parent nodes directly\r\n\t\tif( !_.parents.length && _.listener ){\r\n\t\t\t_.listener.trigger( 'immediate', node, frozen );\r\n\t\t}\r\n\t\tfor (var i = _.parents.length - 1; i >= 0; i--) {\r\n\t\t\tif( i == 0 ){\r\n\t\t\t\tthis.refresh( _.parents[i], node, frozen, false );\r\n\t\t\t}\r\n\t\t\telse{\r\n\r\n\t\t\t\tthis.markDirty( _.parents[i], [node, frozen] );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\tremove: function( node, attrs ){\r\n\t\tvar trans = node.__.trans;\r\n\t\tif( trans ){\r\n\t\t\tfor( var l = attrs.length - 1; l >= 0; l-- )\r\n\t\t\t\tdelete trans[ attrs[l] ];\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar me = this,\r\n\t\t\tfrozen = this.copyMeta( node ),\r\n\t\t\tisFrozen\r\n\t\t;\r\n\r\n\t\tUtils.each( node, function( child, key ){\r\n\t\t\tisFrozen = child && child.__;\r\n\r\n\t\t\tif( isFrozen ){\r\n\t\t\t\tme.removeParent( child, node );\r\n\t\t\t}\r\n\r\n\t\t\tif( attrs.indexOf( key ) != -1 ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif( isFrozen )\r\n\t\t\t\tme.addParent( child, frozen );\r\n\r\n\t\t\tfrozen[ key ] = child;\r\n\t\t});\r\n\r\n\t\tnode.__.freezeFn( frozen );\r\n\t\tthis.refreshParents( node, frozen );\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\tsplice: function( node, args ){\r\n\t\tvar _ = node.__,\r\n\t\t\ttrans = _.trans\r\n\t\t;\r\n\r\n\t\tif( trans ){\r\n\t\t\ttrans.splice.apply( trans, args );\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar me = this,\r\n\t\t\tfrozen = this.copyMeta( node ),\r\n\t\t\tindex = args[0],\r\n\t\t\tdeleteIndex = index + args[1],\r\n\t\t\tcon, child\r\n\t\t;\r\n\r\n\t\t// Clone the array\r\n\t\tUtils.each( node, function( child, i ){\r\n\r\n\t\t\tif( child && child.__ ){\r\n\t\t\t\tme.removeParent( child, node );\r\n\r\n\t\t\t\t// Skip the nodes to delete\r\n\t\t\t\tif( i < index || i>= deleteIndex )\r\n\t\t\t\t\tme.addParent( child, frozen );\r\n\t\t\t}\r\n\r\n\t\t\tfrozen[i] = child;\r\n\t\t});\r\n\r\n\t\t// Prepare the new nodes\r\n\t\tif( args.length > 1 ){\r\n\t\t\tfor (var i = args.length - 1; i >= 2; i--) {\r\n\t\t\t\tchild = args[i];\r\n\t\t\t\tcon = child && child.constructor;\r\n\r\n\t\t\t\tif( con == Array || con == Object )\r\n\t\t\t\t\tchild = this.freeze( child, _.notify, _.freezeFn, _.live );\r\n\r\n\t\t\t\tif( child && child.__ )\r\n\t\t\t\t\tthis.addParent( child, frozen );\r\n\r\n\t\t\t\targs[i] = child;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// splice\r\n\t\tArray.prototype.splice.apply( frozen, args );\r\n\r\n\t\tnode.__.freezeFn( frozen );\r\n\t\tthis.refreshParents( node, frozen );\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\ttransact: function( node ) {\r\n\t\tvar me = this,\r\n\t\t\ttransacting = node.__.trans,\r\n\t\t\ttrans\r\n\t\t;\r\n\r\n\t\tif( transacting )\r\n\t\t\treturn transacting;\r\n\r\n\t\ttrans = node.constructor == Array ? [] : {};\r\n\r\n\t\tUtils.each( node, function( child, key ){\r\n\t\t\ttrans[ key ] = child;\r\n\t\t});\r\n\r\n\t\tnode.__.trans = trans;\r\n\r\n\t\t// Call run automatically in case\r\n\t\t// the user forgot about it\r\n\t\tUtils.nextTick( function(){\r\n\t\t\tif( node.__.trans )\r\n\t\t\t\tme.run( node );\r\n\t\t});\r\n\r\n\t\treturn trans;\r\n\t},\r\n\r\n\trun: function( node ) {\r\n\t\tvar me = this,\r\n\t\t\ttrans = node.__.trans\r\n\t\t;\r\n\r\n\t\tif( !trans )\r\n\t\t\treturn node;\r\n\r\n\t\t// Remove the node as a parent\r\n\t\tUtils.each( trans, function( child, key ){\r\n\t\t\tif( child && child.__ ){\r\n\t\t\t\tme.removeParent( child, node );\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tdelete node.__.trans;\r\n\r\n\t\tvar result = this.replace( node, trans );\r\n\t\treturn result;\r\n\t},\r\n\r\n\tpivot: function( node ){\r\n\t\tnode.__.pivot = 1;\r\n\t\tthis.unpivot( node );\r\n\t\treturn node;\r\n\t},\r\n\r\n\tunpivot: function( node ){\r\n\t\tUtils.nextTick( function(){\r\n\t\t\tnode.__.pivot = 0;\r\n\t\t});\r\n\t},\r\n\r\n\trefresh: function( node, oldChild, newChild, returnUpdated ){\r\n\t\tvar me = this,\r\n\t\t\ttrans = node.__.trans,\r\n\t\t\tfound = 0\r\n\t\t;\r\n\r\n\t\tif( trans ){\r\n\r\n\t\t\tUtils.each( trans, function( child, key ){\r\n\t\t\t\tif( found ) return;\r\n\r\n\t\t\t\tif( child === oldChild ){\r\n\r\n\t\t\t\t\ttrans[ key ] = newChild;\r\n\t\t\t\t\tfound = 1;\r\n\r\n\t\t\t\t\tif( newChild && newChild.__ )\r\n\t\t\t\t\t\tme.addParent( newChild, node );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tvar frozen = this.copyMeta( node ),\r\n\t\t\tdirty = node.__.dirty,\r\n\t\t\tdirt, replacement, __\r\n\t\t;\r\n\r\n\t\tif( dirty ){\r\n\t\t\tdirt = dirty[0],\r\n\t\t\treplacement = dirty[1]\r\n\t\t}\r\n\r\n\t\tUtils.each( node, function( child, key ){\r\n\t\t\tif( child === oldChild ){\r\n\t\t\t\tchild = newChild;\r\n\t\t\t}\r\n\t\t\telse if( child === dirt ){\r\n\t\t\t\tchild = replacement;\r\n\t\t\t}\r\n\r\n\t\t\tif( child && (__ = child.__) ){\r\n\r\n\t\t\t\t// If there is a trans happening we\r\n\t\t\t\t// don't update a dirty node now. The update\r\n\t\t\t\t// will occur on run.\r\n\t\t\t\tif( !__.trans && __.dirty ){\r\n\t\t\t\t\tchild = me.refresh( child, __.dirty[0], __.dirty[1], true );\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tme.removeParent( child, node );\r\n\t\t\t\tme.addParent( child, frozen );\r\n\t\t\t}\r\n\r\n\t\t\tfrozen[ key ] = child;\r\n\t\t});\r\n\r\n\t\tnode.__.freezeFn( frozen );\r\n\r\n\t\t// If the node was dirty, clean it\r\n\t\tnode.__.dirty = false;\r\n\r\n\t\tif( returnUpdated )\r\n\t\t\treturn frozen;\r\n\r\n\t\tthis.refreshParents( node, frozen );\r\n\t},\r\n\r\n\tfixChildren: function( node, oldNode ){\r\n\t\tvar me = this;\r\n\t\tUtils.each( node, function( child ){\r\n\t\t\tif( !child || !child.__ )\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// If the child is linked to the node,\r\n\t\t\t// maybe its children are not linked\r\n\t\t\tif( child.__.parents.indexOf( node ) != -1 )\r\n\t\t\t\treturn me.fixChildren( child );\r\n\r\n\t\t\t// If the child wasn't linked it is sure\r\n\t\t\t// that it wasn't modified. Just link it\r\n\t\t\t// to the new parent\r\n\t\t\tif( child.__.parents.length == 1 )\r\n\t\t\t\treturn child.__.parents = [ node ];\r\n\r\n\t\t\tif( oldNode )\r\n\t\t\t\tme.removeParent( child, oldNode );\r\n\r\n\t\t\tme.addParent( child, node );\r\n\t\t});\r\n\t},\r\n\r\n\tcopyMeta: function( node ){\r\n\t\tvar me = this,\r\n\t\t\tfrozen\r\n\t\t;\r\n\r\n\t\tif( node.constructor == Array ){\r\n\t\t\tfrozen = this.createArray( node.length );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfrozen = Object.create( Mixins.Hash );\r\n\t\t}\r\n\r\n\t\tvar _ = node.__;\r\n\r\n\t\tUtils.addNE( frozen, {__: {\r\n\t\t\tnotify: _.notify,\r\n\t\t\tlistener: _.listener,\r\n\t\t\tparents: _.parents.slice( 0 ),\r\n\t\t\ttrans: _.trans,\r\n\t\t\tdirty: false,\r\n\t\t\tfreezeFn: _.freezeFn,\r\n\t\t\tpivot: _.pivot,\r\n\t\t\tlive: _.live\r\n\t\t}});\r\n\r\n\t\tif( _.pivot )\r\n\t\t\tthis.unpivot( frozen );\r\n\r\n\t\treturn frozen;\r\n\t},\r\n\r\n\trefreshParents: function( oldChild, newChild ){\r\n\t\tvar _ = oldChild.__,\r\n\t\t\ti\r\n\t\t;\r\n\r\n\t\tif( _.listener )\r\n\t\t\tthis.trigger( newChild, 'update', newChild, _.live );\r\n\r\n\t\tif( !_.parents.length ){\r\n\t\t\tif( _.listener ){\r\n\t\t\t\t_.listener.trigger( 'immediate', oldChild, newChild );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (i = _.parents.length - 1; i >= 0; i--) {\r\n\t\t\t\t// If there is more than one parent, mark everyone as dirty\r\n\t\t\t\t// but the last in the iteration, and when the last is refreshed\r\n\t\t\t\t// it will update the dirty nodes.\r\n\t\t\t\tif( i == 0 )\r\n\t\t\t\t\tthis.refresh( _.parents[i], oldChild, newChild, false );\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.markDirty( _.parents[i], [oldChild, newChild] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tmarkDirty: function( node, dirt ){\r\n\t\tvar _ = node.__,\r\n\t\t\ti\r\n\t\t;\r\n\t\t_.dirty = dirt;\r\n\r\n\t\t// If there is a transaction happening in the node\r\n\t\t// update the transaction data immediately\r\n\t\tif( _.trans )\r\n\t\t\tthis.refresh( node, dirt[0], dirt[1] );\r\n\r\n\t\tfor ( i = _.parents.length - 1; i >= 0; i-- ) {\r\n\r\n\t\t\tthis.markDirty( _.parents[i], dirt );\r\n\t\t}\r\n\t},\r\n\r\n\tremoveParent: function( node, parent ){\r\n\t\tvar parents = node.__.parents,\r\n\t\t\tindex = parents.indexOf( parent )\r\n\t\t;\r\n\r\n\t\tif( index != -1 ){\r\n\t\t\tparents.splice( index, 1 );\r\n\t\t}\r\n\t},\r\n\r\n\taddParent: function( node, parent ){\r\n\t\tvar parents = node.__.parents,\r\n\t\t\tindex = parents.indexOf( parent )\r\n\t\t;\r\n\r\n\t\tif( index == -1 ){\r\n\t\t\tparents[ parents.length ] = parent;\r\n\t\t}\r\n\t},\r\n\r\n\ttrigger: function( node, eventName, param, now ){\r\n\t\tvar listener = node.__.listener,\r\n\t\t\tticking = listener.ticking\r\n\t\t;\r\n\r\n\t\tif( now ){\r\n\t\t\tif( ticking || param ){\r\n\t\t\t\tlistener.ticking = 0;\r\n\t\t\t\tlistener.trigger( eventName, ticking || param );\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlistener.ticking = param;\r\n\t\tif( !ticking ){\r\n\t\t\tUtils.nextTick( function(){\r\n\t\t\t\tif( listener.ticking ){\r\n\t\t\t\t\tvar updated = listener.ticking;\r\n\t\t\t\t\tlistener.ticking = 0;\r\n\t\t\t\t\tlistener.trigger( eventName, updated );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\tcreateListener: function( frozen ){\r\n\t\tvar l = frozen.__.listener;\r\n\r\n\t\tif( !l ) {\r\n\t\t\tl = Object.create(Emitter, {\r\n\t\t\t\t_events: {\r\n\t\t\t\t\tvalue: {},\r\n\t\t\t\t\twritable: true\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tfrozen.__.listener = l;\r\n\t\t}\r\n\r\n\t\treturn l;\r\n\t},\r\n\r\n\tcreateArray: (function(){\r\n\t\t// Set createArray method\r\n\t\tif( [].__proto__ )\r\n\t\t\treturn function( length ){\r\n\t\t\t\tvar arr = new Array( length );\r\n\t\t\t\tarr.__proto__ = Mixins.List;\r\n\t\t\t\treturn arr;\r\n\t\t\t}\r\n\t\treturn function( length ){\r\n\t\t\tvar arr = new Array( length ),\r\n\t\t\t\tmethods = Mixins.arrayMethods\r\n\t\t\t;\r\n\t\t\tfor( var m in methods ){\r\n\t\t\t\tarr[ m ] = methods[ m ];\r\n\t\t\t}\r\n\t\t\treturn arr;\r\n\t\t}\r\n\t})()\r\n};\r\n//#build\r\n\r\nmodule.exports = Frozen;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/freezer-js/src/frozen.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/freezer-js/src/frozen.js?");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("'use strict';\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = Object.keys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tto[keys[i]] = from[keys[i]];\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/object-assign/index.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/object-assign/index.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1),\r\n\tdeepSettings = __webpack_require__(10),\r\n\tobjectAssign = __webpack_require__(8)\r\n;\r\n\r\nvar components = {};\r\nvar typeCheckOrder = [];\r\n\r\nvar TypeField = React.createClass({\r\n\tcomponents: {},\r\n\ttypeCheckOrder: [],\r\n\r\n\tcontextTypes: {\r\n\t\ttypeDefaults: React.PropTypes.object\r\n\t},\r\n\r\n\trender: function() {\r\n\t\tvar Component = this.getComponent(),\r\n\t\t\tsettings = objectAssign(\r\n\t\t\t\t{},\r\n\t\t\t\tthis.context.typeDefaults[ this.props.type ],\r\n\t\t\t\tthis.props.settings\r\n\t\t\t)\r\n\t\t;\r\n\r\n\t\tthis.addDeepSettings( settings );\r\n\r\n\t\treturn React.createElement( Component, {\r\n\t\t\tvalue: this.props.value,\r\n\t\t\tbinding:this.props.binding,\r\n\t\t\tsettings: settings,\r\n\t\t\tonUpdated: this.props.onUpdated,\r\n\t\t\tid: this.props.id,\r\n\t\t\tref: 'field'\r\n\t\t});\r\n\t},\r\n\r\n\tgetComponent: function(){\r\n\t\tvar type = this.props.type;\r\n\t\tif( !type )\r\n\t\t\ttype = this.guessType( this.props.value );\r\n\r\n\t\tthis.fieldType = type;\r\n\r\n\t\treturn this.components[ type ];\r\n\t},\r\n\r\n\tguessType: function( value ){\r\n\t\tvar type = false,\r\n\t\t\ti = 0,\r\n\t\t\ttypes = this.typeCheckOrder,\r\n\t\t\tcomponent\r\n\t\t;\r\n\r\n\t\twhile( !type && i < types.length ){\r\n\t\t\tcomponent = this.components[ types[i] ].prototype;\r\n\t\t\tif( component.isType && component.isType( value ) )\r\n\t\t\t\ttype = types[i++];\r\n\t\t\telse\r\n\t\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn type || 'object';\r\n\t},\r\n\r\n\tgetValidationErrors: function( jsonValue ){\r\n\t\treturn this.refs.field.getValidationErrors( jsonValue );\r\n\t},\r\n\r\n\taddDeepSettings: function( settings ){\r\n\t\tvar parentSettings = this.props.parentSettings || {},\r\n\t\t\tdeep\r\n\t\t;\r\n\r\n\t\tfor( var key in deepSettings ){\r\n\t\t\tdeep = deepSettings[ key ]( parentSettings[key], settings[key] );\r\n\t\t\tif( typeof deep != 'undefined' )\r\n\t\t\t\tsettings[ key ] = deep;\r\n\t\t}\r\n \t}\r\n});\r\n\r\nTypeField.registerType = function( name, Component, selectable ){\r\n\tvar proto = TypeField.prototype;\r\n\tproto.components[ name ] = Component;\r\n\tif( selectable )\r\n\t\tproto.typeCheckOrder.unshift( name );\r\n};\r\n\r\nmodule.exports = TypeField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/TypeField.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/TypeField.js?");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("module.exports = {\r\n\tediting: function( parentValue, value ){\r\n\t\tif( typeof value != 'undefined' )\r\n\t\t\treturn value;\r\n\r\n\t\tif( parentValue == 'always' )\r\n\t\t\treturn 'always';\r\n\r\n\t\t// else return undefined: do not override\r\n\t},\r\n\tadder: function( parentValue, value ){\r\n\r\n\t\tif( typeof value != 'undefined' )\r\n\t\t\treturn value;\r\n\t\tif( typeof parentValue != 'undefined' )\r\n\t\t\treturn parentValue;\r\n\r\n\t\treturn true;\r\n\t},\r\n\tfixedFields: function( parentValue, value ){\r\n\t\tif( typeof value != 'undefined' )\r\n\t\t\treturn value;\r\n\r\n\t\tif( typeof parentValue == 'boolean' )\r\n\t\t\treturn parentValue;\r\n\t}\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/deepSettings.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/deepSettings.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1),\r\n\tField = __webpack_require__(12),\r\n\tassign = __webpack_require__(8),\r\n\tCompoundFieldMixin = __webpack_require__(14)\r\n;\r\n\r\n/**\r\n * Component for editing a hash.\r\n * @param  {FreezerNode} value The value of the object.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n */\r\nvar ObjectField = React.createClass({\r\n\tmixins: [CompoundFieldMixin],\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\tgetStateFromProps: function( props ){\r\n\t\treturn {\r\n\t\t\tediting: props.settings.editing || false,\r\n\t\t\tfields: assign({}, props.settings && props.settings.fields || {})\r\n\t\t};\r\n\t},\r\n\r\n\tdefaultValue: {},\r\n\tcomponentWillReceiveProps: function(nextProps) {\r\n\t\tif (this.props.settings.fields !== nextProps.settings.fields) {\r\n\t\t\tthis.setState({\r\n\t\t\t\tfields: assign({}, nextProps.settings && nextProps.settings.fields || {})\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\trender: function(){\r\n\t\tvar me = this,\r\n\t\t\tsettings = this.props.settings,\r\n\t\t\tclassName = this.state.editing || settings.header === false ? 'open jsonObject jsonCompound' : 'jsonObject jsonCompound',\r\n\t\t\topenHash = '',\r\n\t\t\tdefinitions = this.state.fields, bindings = this.state.bindings,\r\n\t\t\tattrs = [],\r\n\t\t\tvalue = assign({}, this.props.value ),\r\n\t\t\tfixedFields = this.getFixedFields(),\r\n\t\t\thidden = this.getHiddenFields(),\r\n\t\t\tgroupCount = 0,\r\n\t\t\tdefinition\r\n\t\t;\r\n\r\n\t\tthis.getFieldOrder().forEach( function( field ){\r\n\t\t\t// If the field is an array handle grouping\r\n\t\t\tif( field.constructor === Array )\r\n\t\t\t\tattrs.push( me.renderGroup( field, fixedFields, ++groupCount ) );\r\n\t\t\telse if( !hidden[ field ] )\r\n\t\t\t\tattrs.push( me.renderField( field, fixedFields ) );\r\n\t\t});\r\n\r\n\t\tvar openHashChildren = [ attrs ];\r\n\t\tif( settings.adder !== false ){\r\n\t\t\topenHashChildren.push( this.renderAdder() );\r\n\t\t}\r\n\r\n\t\topenHash = React.DOM.div({ key: 'o', className: 'jsonChildren'}, openHashChildren);\r\n\t\treturn React.DOM.span({className: className}, [\r\n\t\t\tthis.renderHeader(),\r\n\t\t\topenHash\r\n\t\t]);\r\n\t},\r\n\r\n\trenderField: function( key, fixedFields ){\r\n\t\tvar value = this.props.value[ key ],\r\n\t\t\tdefinition = this.state.fields[ key ] || {},\r\n\t\t\tbinding = this.props.binding && this.props.binding[ key ],\r\n\t\t\tfixed = fixedFields === true || typeof fixedFields == 'object' && fixedFields[ key ]\r\n\t\t;\r\n\r\n\t\tif( !definition.settings )\r\n\t\t\tdefinition.settings = {};\r\n\r\n\t\treturn React.createElement( Field, {\r\n\t\t\tvalue: value,\r\n\t\t\tkey: key,\r\n\t\t\tname: key,\r\n\t\t\tref: key,\r\n\t\t\tfixed: fixed,\r\n\t\t\tid: this.props.id,\r\n\t\t\tdefinition: definition,\r\n\t\t\tbinding:binding,\r\n\t\t\tonBindingUpdated: this.updateBinding,\r\n\t\t\tonUpdated: this.updateField,\r\n\t\t\tonDeleted: this.deleteField,\r\n\t\t\tparentSettings: this.props.settings\r\n\t\t});\r\n\t},\r\n\r\n\trenderGroup: function( fieldNames, fixedFields, groupNumber ){\r\n\t\tvar me = this,\r\n\t\t\tfields = []\r\n\t\t;\r\n\r\n\t\tfieldNames.forEach( function( field ){\r\n\t\t\tfields.push( me.renderField( field, fixedFields ) );\r\n\t\t});\r\n\r\n\t\treturn React.DOM.div({ className: 'jsonGroup jsonGroup_' + groupNumber }, fields );\r\n\t},\r\n\r\n\tgetDefaultHeader: function(){\r\n\t\treturn 'Map [' + Object.keys( this.props.value ).length + ']';\r\n\t},\r\n\r\n\tgetDefaultAdder: function(){\r\n\t\treturn '+ Add field';\r\n\t},\r\n\r\n\tupdateField: function( key, value ){\r\n\t\tthis.checkEditingSetting( key );\r\n\t\tthis.props.value.set( key, value );\r\n\t},\r\n\tupdateBinding: function( key, value ){\r\n\t\tthis.props.binding.set( key, value );\r\n\t},\r\n\r\n\tdeleteField: function( key ){\r\n\t\tthis.props.value.remove( key );\r\n\t},\r\n\r\n\tgetValidationErrors: function( jsonValue ){\r\n\t\tvar me = this,\r\n\t\t\terrors = [],\r\n\t\t\tattrs = Object.keys( this.refs )\r\n\t\t;\r\n\r\n\t\tattrs.forEach( function( attr ){\r\n\t\t\tvar error = me.refs[attr].getValidationErrors();\r\n\t\t\tif( error )\r\n\t\t\t\terrors = errors.concat( error );\r\n\t\t});\r\n\r\n\t\treturn errors;\r\n\t},\r\n\r\n\tgetFieldOrder: function(){\r\n\t\tvar me = this,\r\n\t\t\tsettingsOrder = this.props.settings.order,\r\n\t\t\torderType = typeof settingsOrder,\r\n\t\t\tfields = this.props.settings.fields || {},\r\n\t\t\tgroup\r\n\t\t;\r\n\r\n\t\tif( !settingsOrder || (orderType != 'function' && settingsOrder.constructor !== Array) )\r\n\t\t\treturn Object.keys( this.props.value );\r\n\r\n\t\tvar value = assign( {}, this.props.value ),\r\n\t\t\torder = []\r\n\t\t;\r\n\r\n\t\tif( orderType == 'function' )\r\n\t\t\treturn settingsOrder( value );\r\n\r\n\t\t// Add fields in the array\r\n\t\tif( settingsOrder.constructor === Array ){\r\n\t\t\tsettingsOrder.forEach( function( field ){\r\n\r\n\t\t\t\t// An array, handle group\r\n\t\t\t\tif( field.constructor == Array ){\r\n\t\t\t\t\tgroup = [];\r\n\t\t\t\t\tfield.forEach( function( groupField ){\r\n\t\t\t\t\t\tif( me.addFieldToOrder( groupField, value, fields ) ){\r\n\t\t\t\t\t\t\tgroup.push( groupField );\r\n\r\n\t\t\t\t\t\t\t// Delete them from current values\r\n\t\t\t\t\t\t\tdelete value[ groupField ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif( group.length )\r\n\t\t\t\t\t\torder.push( group );\r\n\t\t\t\t}\r\n\t\t\t\telse if( me.addFieldToOrder( field, value, fields ) ){\r\n\t\t\t\t\torder.push( field );\r\n\r\n\t\t\t\t\t// Delete them from current values\r\n\t\t\t\t\tdelete value[ field ];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Add the keys left in the value\r\n\t\tfor( var key in value ){\r\n\t\t\tif( order.indexOf( key ) == -1 )\r\n\t\t\t\torder.push( key );\r\n\t\t}\r\n\r\n\t\treturn order;\r\n\t},\r\n\r\n\t/**\r\n\t * Checks when a field that appears in the sort settings needs to be added to\r\n\t * the fieldOrder array\r\n\t *\r\n\t * @param {String} field The field name\r\n\t */\r\n\taddFieldToOrder: function( field, value, fields ){\r\n\t\treturn typeof value[ field ] != 'undefined' || fields[ field ] && fields[ field ].type == 'react';\r\n\t},\r\n\r\n\tgetHiddenFields: function(){\r\n\t\tvar hidden = this.props.settings.hiddenFields,\r\n\t\t\tfields = {}\r\n\t\t;\r\n\t\tif( !hidden )\r\n\t\t\treturn fields;\r\n\r\n\t\thidden.forEach( function( f ){\r\n\t\t\tfields[ f ] = 1;\r\n\t\t});\r\n\r\n\t\treturn fields;\r\n\t}\r\n});\r\n\r\nmodule.exports = ObjectField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/ObjectField.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/ObjectField.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1),\r\n\tobjectAssign = __webpack_require__(8),\r\n\tValidation = __webpack_require__(13),\r\n\tTypeField = __webpack_require__(9)\r\n\r\n;\r\n\r\nvar clearObjProps = function (obj) {\r\n\tfor(var k in obj) {\r\n\t\tif(typeof obj[k] == \"object\"\r\n\t\t\t&& obj[k] !== null\r\n\t\t\t&& !(obj[k] instanceof Array)\r\n\t\t\t&& !(obj[k] instanceof String)\r\n\t\t\t&& !(obj[k] instanceof Number)) {\r\n\r\n\t\t\tclearObjProps(obj[k]);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tswitch(typeof obj[k]) {\r\n\t\t\tcase 'undefined':\r\n\t\t\tcase 'boolean':\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'number':\r\n\t\t\t\tobj[k] = undefined;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tobj[k] = [];\r\n\t\t}\r\n\t}\r\n\treturn  obj;\r\n}\r\n/**\r\n * Field component that represent each Array element or Object field.\r\n * @param  {string} name The key of the attribute in the parent.\r\n * @param  {Mixed} value The value of the attribute.\r\n * @param {Mixed} original The value of the attibute in the original json to highlight the changes.\r\n * @param {FreezerNode} parent The parent node to notify attribute updates.\r\n */\r\nvar Field = React.createClass({\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn {error: false};\r\n\t},\r\n\tgetDefaultProps: function(){\r\n\t\treturn {\r\n\t\t\tdefinition: {}\r\n\t\t};\r\n\t},\r\n\trender: function(){\r\n\t\tvar definition = this.props.definition || {},\r\n\t\t\t\tbinding = this.props.binding,\r\n\t\t\tclassName = 'jsonField',\r\n\t\t\ttype = definition.type || TypeField.prototype.guessType( this.props.value ),\r\n\t\t\tid = this.props.id + '_' + this.props.name,\r\n\t\t\terror = '',\r\n\t\t\ttypeField\r\n\t\t;\r\n\r\n\r\n\r\n\t\tif( type == 'react' )\r\n\t\t\treturn this.renderReactField( definition );\r\n\r\n\t\tif (this.useBinding() && binding !== undefined) {\r\n\t\t\t//render Object with binding\r\n\t\t\ttypeField = [this.renderBindingField(id)];\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttypeField = [this.renderTypeField(type, id)];\r\n\t\t}\r\n\t\tclassName += ' ' + type + 'Field';\r\n\r\n\t\tif( this.state.error ){\r\n\t\t\tclassName += ' jsonError';\r\n\t\t\tif( this.state.error !== true )\r\n\t\t\t\terror = React.DOM.span({ key:'e', className: 'jsonErrorMsg' }, this.state.error );\r\n\t\t}\r\n\r\n\t\tvar jsonName = [ React.DOM.label({ key: 's1', htmlFor: id }, (definition.title || this.props.name) + ':' ) ];\r\n\r\n\t\tif( this.props.fixed ){\r\n\t\t\t// If the field cannot be removed, add a placeholder to maintain the design\r\n\t\t\tjsonName.unshift( React.DOM.span({ key:'f', className: 'jsonFixed' }) );\r\n\t\t}\r\n\t\telse{\r\n\t\t\tjsonName.unshift( React.DOM.a({ key:'a', href: '#', className: 'jsonRemove', onClick: this.handleRemove}, 'x') );\r\n\t\t}\r\n\r\n\t\tif(this.useBinding() && binding === undefined){\r\n\t\t\ttypeField.unshift( React.DOM.a({ key:'b', className: 'jsonBind', onClick: this.handleAddBinding}, '=') );\r\n\t\t}\r\n\r\n\t\tif(this.props.value === undefined && !(this.useBinding() && binding !== undefined) ){\r\n\t\t\t// If the field cannot be removed, add a placeholder to maintain the design\r\n\t\t\ttypeField.unshift( React.DOM.span({ key:'f', className: 'jsonFixed' }) );\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttypeField.unshift( React.DOM.a({ key:'r', className: 'jsonReset', onClick: this.handleReset}, 'x') );\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn React.DOM.div({className: className}, [\r\n\t\t\tReact.DOM.span( {className: 'jsonName', key: 'n'}, jsonName ),\r\n\t\t\tReact.DOM.span( {className: 'jsonValue', key: 'v'}, typeField ),\r\n\t\t\terror\r\n\t\t]);\r\n\t},\r\n    useBinding:function(){\r\n\t\treturn this.props.parentSettings && this.props.parentSettings.useBinding;\r\n\t},\r\n\trenderTypeField: function( type, id ){\r\n\t\tvar definition = this.props.definition,\r\n\t\t\tsettings = objectAssign( {}, definition.settings || {} ),\r\n\t\t\tcomponent\r\n\t\t;\r\n\r\n\t\tif( definition.fields )\r\n\t\t\tsettings.fields = definition.fields;\r\n\r\n\t\tcomponent = React.createElement( TypeField, {\r\n\t\t\ttype: type,\r\n\t\t\tvalue: this.props.value,\r\n\t\t\tbinding:this.props.binding,\r\n\t\t\tsettings: settings,\r\n\t\t\tonUpdated: this.onUpdated,\r\n\t\t\tref: 'typeField',\r\n\t\t\tid: id,\r\n\t\t\tparentSettings: this.props.parentSettings\r\n\t\t});\r\n\t\treturn component;\r\n\t},\r\n\trenderBindingField: function(id) {\r\n\r\n\t\treturn React.createElement(TypeField, {\r\n\t\t\ttype: 'object',\r\n\t\t\tvalue: this.props.binding,\r\n\t\t\tsettings: {\r\n\t\t\t\tfields: {\r\n\t\t\t\t\tpath:{type:'string'},\r\n\t\t\t\t\tmode: {\r\n\t\t\t\t\t\ttype: 'select', settings: {\r\n\t\t\t\t\t\t\tediting: false,\r\n\t\t\t\t\t\t\toptions: ['OneWay', 'TwoWay','OneTime'].map(function (key, value) {\r\n\t\t\t\t\t\t\t\treturn {value: key, label: key};\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tconverter: {\r\n\t\t\t\t\t\ttype: 'codeEditor'\r\n\t\t\t\t\t},\r\n\t\t\t\t\tconverterArgs:{type:'string'}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tonUpdated: this.onBindingUpdated,\r\n\t\t\tref: 'typeField',\r\n\t\t\tid: id,\r\n\t\t\tparentSettings: this.props.parentSettings\r\n\t\t});\r\n\t},\r\n\r\n\trenderReactField: function( definition ){\r\n\t\treturn React.DOM.div( { className: 'jsonField reactField' }, definition.output );\r\n\t},\r\n\r\n\thandleRemove: function( e ){\r\n\t\tthis.props.onDeleted( this.props.name );\r\n\t},\r\n\thandleReset: function( e ){\r\n\t\tvar definition = this.props.definition || {},type = definition.type || TypeField.prototype.guessType( this.props.value );\r\n\t\tif (type === 'object') {\r\n\t\t\tthis.onUpdated(clearObjProps(this.props.value.toJS()));\r\n\t\t}else{\r\n\t\t\tthis.onUpdated(undefined);\r\n\t\t}\r\n\t},\r\n\thandleAddBinding:function(e){\r\n\t\tvar defaultValues = {\r\n\t\t\tpath: undefined,\r\n\t\t\tconverter: undefined,\r\n\t\t\tconverterArgs:undefined,\r\n\t\t\tmode: 'OneWay'\r\n\t\t};\r\n\t\tthis.onBindingUpdated(defaultValues);\r\n\r\n\t},\r\n\r\n\tshouldComponentUpdate: function( nextProps, nextState ){\r\n\t\treturn nextProps.value != this.props.value ||  nextProps.binding != this.props.binding  || nextState.error != this.state.error;\r\n\t},\r\n\r\n\tonUpdated: function( value ) {\r\n\t\tif (this.useBinding() && this.props.binding !== undefined){\r\n\t\t\tthis.onBindingUpdated(value);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar definition = this.props.definition;\r\n\t\tif (this.props.value !== value) {\r\n\t\t\tthis.props.onUpdated(this.props.name, value);\r\n\t\t\tif (definition.onChange)\r\n\t\t\t\tdefinition.onChange(value, this.props.value);\r\n\t\t}\r\n\r\n\t},\r\n\tonBindingUpdated: function( value ) {\r\n\t\tthis.props.onBindingUpdated(this.props.name, value);\r\n\t},\r\n\r\n\tgetValidationErrors: function( jsonValue ){\r\n\t\tvar childErrors = [],\r\n\t\t\tvalidates = this.props.definition.validates,\r\n\t\t\tname = this.props.name,\r\n\t\t\tfield = this.refs.typeField\r\n\t\t;\r\n\r\n\t\tif( !field )\r\n\t\t\treturn [];\r\n\r\n\t\tif( field.fieldType == 'object' ){\r\n\t\t\tchildErrors = field.getValidationErrors( jsonValue );\r\n\t\t\tchildErrors.forEach( function( error ){\r\n\t\t\t\tif( !error.path )\r\n\t\t\t\t\terror.path = name;\r\n\t\t\t\telse\r\n\t\t\t\t\terror.path = name + '.' + error.path;\r\n\t\t\t});\r\n\r\n\t\t\tif( childErrors.length )\r\n\t\t\t\tthis.setState( {error: true} );\r\n\t\t}\r\n\r\n\t\tif( !validates )\r\n\t\t\treturn childErrors;\r\n\r\n\r\n\t\tvar error = Validation.getValidationError( this.props.value, jsonValue, validates ),\r\n\t\t\tmessage\r\n\t\t;\r\n\r\n\t\tif( error ){\r\n\t\t\tmessage = this.props.definition.errorMessage;\r\n\t\t\tif( !message )\r\n\t\t\t\tmessage = ( this.props.definition.label || this.props.name ) + ' value is not valid.';\r\n\r\n\t\t\terror.path = name;\r\n\t\t\terror.message = message;\r\n\t\t\tthis.setState( {error: message} );\r\n\t\t\tchildErrors = childErrors.concat( [error] );\r\n\t\t}\r\n\t\telse if( this.state.error ){\r\n\t\t\tthis.setState( {error: false} );\r\n\t\t}\r\n\r\n\t\treturn childErrors;\r\n\t}\r\n\r\n});\r\n\r\nmodule.exports = Field;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Field.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/Field.js?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("'use strict';\r\n\r\nvar ValidationMethods = {\r\n  required: function( value ){\r\n      if( !value )\r\n          return false;\r\n\r\n      // Empty trimmed string does not validate\r\n      if( typeof value == 'string' && !value.trim() )\r\n          return false;\r\n\r\n      return true;\r\n  },\r\n\r\n  email: function( value ){\r\n\r\n      // If nothing given, maybe the field is not required\r\n      // so it passes the check.\r\n      if( !value )\r\n          return true;\r\n\r\n      /* http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\r\n      var re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n      return re.test( value );\r\n  },\r\n\r\n  length: function( value, jsonValue, min, max ){\r\n      if( !min )\r\n          min = 0;\r\n      if( !max )\r\n          max = Infinity;\r\n\r\n      return ( value.length >= min && value.length <= max );\r\n  },\r\n\r\n  integer: function( value, jsonValue, min, max ){\r\n      if( !min && min !== 0 )\r\n          min = -Infinity;\r\n      if( !max )\r\n          max = Infinity;\r\n\r\n      // Empty string passes the check\r\n      if(!value && value != 0)\r\n          return true;\r\n\r\n      var intVal = parseInt( value );\r\n\r\n      if( value != intVal )\r\n          return false;\r\n\r\n      return ( intVal <= max && intVal >= min );\r\n  },\r\n\r\n  checked: function( value ){\r\n      return value;\r\n  },\r\n\r\n  matches: function( value, jsonValue, path ){\r\n      return value == findInTree( path.split('.'), jsonValue );\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = {\r\n\tgetValidationError: function( value, jsonValue, validates ){\r\n\t\tvar methods = [],\r\n\t\t\terror = false,\r\n\t\t\ti = 0\r\n\t\t;\r\n\r\n\t\t// Store the validation methods in an array\r\n\t\tif( typeof validates == 'string' ){\r\n\t\t\tmethods = parseMethodString( validates );\r\n\t\t}\r\n\t\telse if( typeof validates == 'function' ){\r\n\t\t\tmethods = [ validates ];\r\n\t\t}\r\n\t\telse if( validates && validates.constructor === Array ){\r\n\t\t\tmethods = validates;\r\n\t\t}\r\n\r\n\r\n\t\tvar definition, f, method;\r\n\t\twhile( !error && i < methods.length ){\r\n\t\t\tmethod = methods[i++];\r\n\t\t\tif( typeof method == 'string' ){\r\n\r\n\t\t\t\t// definition {name, args}\r\n\t\t\t\tdefinition = parseMethodName( method );\r\n\t\t\t\tf = ValidationMethods[ definition.name ];\r\n\t\t\t\tif( !f )\r\n\t\t\t\t\tconsole.log( 'Unkown validation method ' + definition.name );\r\n\t\t\t\telse if( !f.apply( null, [ value, jsonValue ].concat( definition.args ) )){\r\n\t\t\t\t\terror = {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tmethod: method\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( typeof method == 'function' ){\r\n\t\t\t\tif( !method( value, jsonValue ) )\r\n\t\t\t\t\terror = {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tmethod: 'custom'\r\n\t\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn error;\r\n\t}\r\n};\r\n\r\n/*\r\n HELPER METHODS\r\n */\r\n\r\nvar parseMethodString = function( string ){\r\n\treturn string.match(/[^\\s\\[]+(\\[[^\\]]+?\\])?/ig);\r\n};\r\n\r\n/**\r\n * Parse a method call in the data-validation attribute.\r\n * @param  {String} methodStr A method call like method[arg1, arg2, ...]\r\n * @return {Object}           An object like {name: 'method', args: [arg1, arg2, ...]}\r\n */\r\nvar parseMethodName = function( methodStr ){\r\n    var parts = methodStr.split('['),\r\n        definition = {\r\n            name: parts[0],\r\n            args: []\r\n        },\r\n        args\r\n    ;\r\n\r\n    if( parts.length > 1 ){\r\n        args = parts[1];\r\n\r\n        if( args[ args.length - 1 ] == ']' )\r\n            args = args.slice(0, args.length - 1);\r\n\r\n        definition.args = args.split(/\\s*,\\s*/);\r\n    }\r\n\r\n    return definition;\r\n};\r\n\r\n/**\r\n * Get the value of a field node, hiding the differences among\r\n * different type of inputs.\r\n *\r\n * @param  {DOMElement} field The field.\r\n * @return {String}       The current value of the given field.\r\n */\r\nvar getFieldValue = function( field ){\r\n    var tagName = field.tagName.toLowerCase();\r\n\r\n    if( tagName == 'input' && field.type == 'checkbox' ){\r\n        return field.checked;\r\n    }\r\n\r\n    if( tagName == 'select' ){\r\n        return field.options[field.selectedIndex].value;\r\n    }\r\n\r\n    return field.value;\r\n};\r\n\r\nfunction findInTree( path, jsonValue ){\r\n\tif( !path.length )\r\n\t\treturn jsonValue;\r\n\r\n\treturn findInTree(path.slice(1), jsonValue[ path[0] ]);\r\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/validation.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/validation.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1),\r\n\tFieldAdder = __webpack_require__(15),\r\n\tassign = __webpack_require__(8)\r\n;\r\n\r\nmodule.exports = {\r\n\trenderHeader: function(){\r\n\t\tvar settingsHeader = this.props.settings.header;\r\n\t\tif( settingsHeader === false )\r\n\t\t\treturn '';\r\n\r\n\t\tvar type = typeof settingsHeader,\r\n\t\t\theader\r\n\t\t;\r\n\r\n\t\tif( type == 'function' ){\r\n\t\t\theader = settingsHeader( this.props.value.toJS() );\r\n\t\t}\r\n\t\telse if( type == 'undefined' ){\r\n\t\t\theader = this.getDefaultHeader();\r\n\t\t}\r\n\t\telse {\r\n\t\t\theader = settingsHeader;\r\n\t\t}\r\n\r\n\t\treturn React.DOM.span({ key: 's', onClick: this.toggleEditing, className: 'compoundToggle' }, header);\r\n\t},\r\n\r\n\ttoggleEditing: function(){\r\n\t\tif( this.state.editing != 'always' && this.props.settings.header !== false )\r\n\t\t\tthis.setState({editing: !this.state.editing});\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( nextProps ){\r\n\t\tif( this.props.settings.editing != nextProps.settings.editing )\r\n\t\t\tthis.setState({ editing: nextProps.editing });\r\n\t},\r\n\r\n\trenderAdder: function( name ){\r\n\t\tvar settingsAdder = this.props.settings.adder,\r\n\t\t\ttype = typeof settingsAdder,\r\n\t\t\tadder\r\n\t\t;\r\n\r\n\t\tif( type == 'function' ){\r\n\t\t\tadder = settingsAdder( this.props.value.toJS() );\r\n\t\t}\r\n\t\telse if( settingsAdder === true || type == 'undefined' ){\r\n\t\t\tadder = this.getDefaultAdder();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tadder = settingsAdder;\r\n\t\t}\r\n\r\n\t\treturn React.createElement( FieldAdder, {\r\n\t\t\tonCreate: this.createField,\r\n\t\t\tname: name,\r\n\t\t\tkey: 'add',\r\n\t\t\ttext: adder\r\n\t\t});\r\n\t},\r\n\r\n\tcreateField: function( key, value, definition ){\r\n\r\n\t\tif( this.props.value[ key ] )\r\n\t\t\treturn console.log( 'Field ' + key + ' already exists.');\r\n\r\n\t\t// Start editing and focus\r\n\t\tdefinition.settings = {\r\n\t\t\tediting: this.state.editing == 'always' ? 'always' : true,\r\n\t\t\tfocus: true\r\n\t\t};\r\n\r\n\t\tvar fields = assign( {}, this.state.fields );\r\n\t\tfields[ key ] = definition;\r\n\r\n\t\tthis.setState({fields: fields});\r\n\t\tthis.props.value.set( key, value );\r\n\t},\r\n\r\n\t/**\r\n\t * Checks if the current key editing setting is true\r\n\t * and set it to false. The editing setting is set\r\n\t * to true when a new child is added to edit it automatically\r\n\t * after is edited it loses the point.\r\n\t *\r\n\t * @param  {String} key The child key\r\n\t */\r\n\tcheckEditingSetting: function( key ){\r\n\t\tvar fields = this.state.fields;\r\n\t\tif( fields[ key ] && fields[key].settings && fields[ key ].settings.focus === true ){\r\n\t\t\tfields = assign({}, fields);\r\n\t\t\tfields[key].settings.focus = false;\r\n\t\t\tthis.setState( {fields: fields} );\r\n\t\t}\r\n\t},\r\n\r\n\tgetFixedFields: function(){\r\n\t\tvar fields = this.props.settings.fixedFields,\r\n\t\t\tfixed = {}\r\n\t\t;\r\n\t\tif( fields && fields.constructor == Array ){\r\n\t\t\tfields.forEach( function( f ){\r\n\t\t\t\tfixed[ f ] = 1;\r\n\t\t\t});\r\n\t\t\treturn fixed;\r\n\t\t}\r\n\t\treturn fields;\r\n\t}\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/CompoundFieldMixin.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./mixins/CompoundFieldMixin.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tTypeField = __webpack_require__(9)\r\n;\r\n\r\n/**\r\n * Component to add fields to an Object or Array.\r\n * @param  {FreezerNode} root The parent to add the attribute.\r\n * @param  {string} name Optional. If provided, the attribute added will have that key (arrays).\r\n *                           Otherwise an input will be shown to let the user define the key.\r\n */\r\nvar FieldAdder = React.createClass({\r\n\tgetInitialState: function(){\r\n\t\treturn {\r\n\t\t\tcreating: this.props.creating || false,\r\n\t\t\tname: this.props.name,\r\n\t\t\ttype: 'string'\r\n\t\t};\r\n\t},\r\n\r\n\trender: function(){\r\n\t\tif( !this.state.creating )\r\n\t\t\treturn React.DOM.a({ className: 'jsonAdd', href: '#', onClick: this.handleCreate }, this.props.text );\r\n\r\n\t\tvar options = this.getTypes().map( function( type ){\r\n\t\t\t\treturn React.DOM.option({value: type, key: type}, type[0].toUpperCase() + type.slice(1));\r\n\t\t\t}),\r\n\t\t\tfieldName\r\n\t\t;\r\n\r\n\t\tif( typeof this.props.name != 'undefined' )\r\n\t\t\tfieldName =  [\r\n\t\t\t\tReact.DOM.span({className: 'jsonName'}, this.props.name),\r\n\t\t\t\tReact.DOM.span(null, ':')\r\n\t\t\t];\r\n\t\telse {\r\n\t\t\tfieldName = [\r\n\t\t\t\tReact.DOM.input({ref: 'keyInput', type: 'text', value: this.state.value, onChange: this.changeKey}),\r\n\t\t\t\tReact.DOM.span(null, ':')\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\treturn React.DOM.div( {className: 'jsonField jsonFieldAdder'}, [\r\n\t\t\tfieldName,\r\n\t\t\tReact.DOM.select({ key: 's', value: this.state.type, onChange: this.changeType, ref: 'typeSelector'}, options),\r\n\t\t\tReact.DOM.button({ key: 'b', onClick: this.createField }, 'OK' ),\r\n\t\t\tReact.DOM.a({ key: 'a', href: '#', className: 'cancelField', onClick: this.handleCancel}, 'Cancel')\r\n\t\t]);\r\n\t},\r\n\r\n\tcomponentDidUpdate: function( prevProps, prevState ){\r\n\t\tif( !prevState.creating && this.state.creating ){\r\n\t\t\tif( this.refs.keyInput )\r\n\t\t\t\tthis.refs.keyInput.getDOMNode().focus();\r\n\t\t\telse\r\n\t\t\t\tthis.refs.typeSelector.getDOMNode().focus();\r\n\t\t}\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( newProps ){\r\n\t\tthis.setState({name: newProps.name});\r\n\t},\r\n\r\n\thandleCreate: function( e ){\r\n\t\te.preventDefault();\r\n\t\tthis.setState({creating: true});\r\n\t},\r\n\r\n\thandleCancel: function( e ){\r\n\t\te.preventDefault();\r\n\t\tthis.setState({creating: false});\r\n\t},\r\n\r\n\tchangeType: function( e ){\r\n\t\tthis.setState({type: e.target.value});\r\n\t},\r\n\r\n\tchangeKey: function( e ){\r\n\t\tthis.setState({name: e.target.value});\r\n\t},\r\n\r\n\tcreateField: function(){\r\n\t\tthis.setState({creating: false});\r\n\r\n\t\tvar value = TypeField.prototype.components[ this.state.type ].prototype.defaultValue;\r\n\r\n\t\tthis.props.onCreate( this.state.name, value, {type: this.state.type });\r\n\t},\r\n\r\n\tgetTypes: function(){\r\n\t\treturn Object.keys( TypeField.prototype.components );\r\n\t}\r\n});\r\n\r\nmodule.exports = FieldAdder;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/FieldAdder.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/FieldAdder.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1),\r\n\tField = __webpack_require__(12),\r\n\tassign = __webpack_require__(8),\r\n\tCompoundFieldMixin = __webpack_require__(14)\r\n;\r\n\r\n/**\r\n * Component for editing an array.\r\n * @param  {FreezerNode} value The value of the array.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n */\r\nvar ArrayField = React.createClass({\r\n\tmixins: [CompoundFieldMixin],\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\tgetStateFromProps: function( props ){\r\n\t\treturn {\r\n\t\t\tediting: props.settings.editing || false,\r\n\t\t\tfields: this.state && this.state.fields || {}\r\n\t\t};\r\n\t},\r\n\r\n\tdefaultValue: [],\r\n\r\n\trender: function(){\r\n\t\tvar settings = this.props.settings,\r\n\t\t\tclassName = this.state.editing ? 'open jsonArray jsonCompound' : 'jsonArray jsonCompound',\r\n\t\t\topenArray = '',\r\n\t\t\tfixedFields = this.getFixedFields(),\r\n\t\t\tdefinitions = this.state.fields\r\n\t\t;\r\n\r\n\t\tvar attrs = [],\r\n\t\t\tdefinition, fixed\r\n\t\t;\r\n\t\tfor (var i = 0; i < this.props.value.length; i++) {\r\n\t\t\tdefinition = definitions[ i ] || {};\r\n\t\t\tif( !definition.settings )\r\n\t\t\t\tdefinition.settings = {};\r\n\r\n\t\t\tfixed = fixedFields === true || typeof fixedFields == 'object' && fixedFields[ i ];\r\n\r\n\t\t\tattrs.push( React.createElement( Field, {\r\n\t\t\t\tvalue: this.props.value[i],\r\n\t\t\t\tkey: i,\r\n\t\t\t\tname: i,\r\n\t\t\t\tid: this.props.id,\r\n\t\t\t\tdefinition: definition,\r\n\t\t\t\tfixed: fixed,\r\n\t\t\t\tonUpdated: this.updateField,\r\n\t\t\t\tonDeleted: this.deleteField,\r\n\t\t\t\tparentSettings: this.props.settings\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\tvar openArrayChildren = [ attrs ];\r\n\t\tif( settings.adder !== false ){\r\n\t\t\topenArrayChildren.push( this.renderAdder( this.props.value.length ) );\r\n\t\t}\r\n\r\n\t\topenArray = React.DOM.div({ key:'o', className: 'jsonChildren' }, openArrayChildren );\r\n\r\n\t\treturn React.DOM.span({className: className}, [\r\n\t\t\tthis.renderHeader(),\r\n\t\t\topenArray\r\n\t\t]);\r\n\t},\r\n\r\n\tgetDefaultHeader: function(){\r\n\t\treturn 'List [' + this.props.value.length + ']';\r\n\t},\r\n\r\n\tgetDefaultAdder: function(){\r\n\t\treturn '+ Add element';\r\n\t},\r\n\r\n\tupdateField: function( key, value ){\r\n\t\tthis.checkEditingSetting( key );\r\n\t\tthis.props.value.set( key, value );\r\n\t},\r\n\r\n\tdeleteField: function( key ){\r\n\t\tvar fields = {};\r\n\r\n\t\tfor( var index in this.state.fields ){\r\n\t\t\tif( index > key ){\r\n\t\t\t\tfields[ index - 1 ] = this.state.fields[ index ];\r\n\t\t\t}\r\n\t\t\telse if( index < key ){\r\n\t\t\t\tfields[ index ] = this.state.fields[ index ];\r\n\t\t\t}\r\n\t\t\t// If they are equal we are deleting the element, do nothing\r\n\t\t}\r\n\r\n\t\tthis.props.value.splice( key, 1 );\r\n\t\tthis.setState( { fields: fields } );\r\n\t},\r\n\r\n\tisType: function( value ){\r\n\t\treturn value && value.constructor == Array;\r\n\t}\r\n});\r\n\r\nmodule.exports = ArrayField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/ArrayField.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/ArrayField.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tLeafMixin = __webpack_require__(18)\r\n;\r\n\r\n\r\n/**\r\n * Component for editing a string.\r\n * @param  {string} value The value of the string.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n * @param {FreezerNode} parent The parent node to let the string component update its value.\r\n */\r\nvar StringField = React.createClass({\r\n\tmixins: [LeafMixin],\r\n\ttypeClass: 'jsonString',\r\n\tinputType: 'text',\r\n\tdefaultValue: '',\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\trender: function(){\r\n\t\treturn this.renderInput();\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.setState({ value: e.target.value });\r\n\t},\r\n\r\n\tisType: function( value ){\r\n\t\treturn typeof value != 'object';\r\n\t}\r\n});\r\n\r\nmodule.exports = StringField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/StringField.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/StringField.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\r\n\r\nvar React = __webpack_require__(1);\r\n\r\nmodule.exports = {\r\n\tgetStateFromProps: function( props ){\r\n\t\treturn {\r\n\t\t\tediting: props.settings.editing || false,\r\n\t\t\tvalue: props.value\r\n\t\t};\r\n\t},\r\n\r\n\trenderInput: function(){\r\n\t\tvar className = this.typeClass;\r\n\r\n\t\tif( !this.state.editing )\r\n\t\t\treturn React.DOM.span( {onClick: this.setEditMode, className: className}, this.getDisplayString() );\r\n\r\n\t\treturn React.DOM.input({\r\n\t\t\ttype: this.inputType,\r\n\t\t\tvalue: this.state.value,\r\n\t\t\tid: this.props.id,\r\n\t\t\tplaceholder: this.props.settings.placeholder || '',\r\n\t\t\tonChange: this.updateValue,\r\n\t\t\tonBlur: this.setValue,\r\n\t\t\tref: 'input',\r\n\t\t\tonKeyDown: this.handleKeyDown\r\n\t\t});\r\n\t},\r\n\r\n\tgetDisplayString: function(){\r\n\t\tif( this.getDisplayModeString )\r\n\t\t\treturn this.getDisplayModeString();\r\n\r\n\t\tif( this.isEmpty() )\r\n\t\t\treturn React.DOM.span( {className: 'jsonNovalue'}, 'No value' );\r\n\r\n\t\treturn this.props.value;\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( nextProps ){\r\n\t\tvar nextState = {},\r\n\t\t\tupdate = false\r\n\t\t;\r\n\r\n\t\tif( this.props.value != nextProps.value ){\r\n\t\t\tupdate = true;\r\n\t\t\tnextState.value = nextProps.value;\r\n\t\t}\r\n\t\tif( this.props.settings.editing != nextProps.settings.editing ){\r\n\t\t\tupdate = true;\r\n\t\t\tnextState.editing = nextProps.editing;\r\n\t\t}\r\n\t\tif( update )\r\n\t\t\tthis.setState( nextState );\r\n\t},\r\n\r\n\tcomponentDidUpdate: function( prevProps, prevState ){\r\n\t\tif( this.state.editing && ! prevState.editing || this.props.settings.focus ){\r\n\t\t\tthis.focus();\r\n\t\t}\r\n\t},\r\n\r\n\tcomponentDidMount: function(){\r\n\t\tif( this.state.editing === true || this.props.settings.focus )\r\n\t\t\tthis.focus();\r\n\t},\r\n\r\n\tsetEditMode: function(){\r\n\t\tthis.setState({editing: true});\r\n\t},\r\n\r\n\tsetValue: function(){\r\n\t\tif( this.state.editing != 'always' )\r\n\t\t\tthis.setState({editing: false});\r\n\t\tthis.props.onUpdated( this.state.value );\r\n\t},\r\n\r\n\ttoggleEditing: function(){\r\n\t\tthis.setState({ editing: !this.state.editing });\r\n\t},\r\n\r\n\thandleKeyDown: function( e ){\r\n\t\tif( e.which == 13 )\r\n\t\t\tthis.setValue();\r\n\t},\r\n\r\n\tfocus: function(){\r\n\t\tvar node = this.refs.input.getDOMNode();\r\n\t\tnode.focus();\r\n\t\tnode.value = node.value;\r\n\t},\r\n\r\n\tisEmpty:function(){\r\n\t\treturn this.props.value === undefined || this.props.value === '';\r\n\t},\r\n\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mixins/LeafFieldMixin.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./mixins/LeafFieldMixin.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1);\r\n\r\n/**\r\n * Component for editing a boolean.\r\n * @param  {string} value The value of the boolean.\r\n */\r\nvar BooleanField = React.createClass({\r\n\r\n\tdefaultValue: false,\r\n\r\n\trender: function(){\r\n\t\tvar className = 'jsonBoolean';\r\n\r\n\t\treturn React.DOM.input({\r\n\t\t\ttype: \"checkbox\",\r\n\t\t\tclassName: className,\r\n\t\t\tid: this.props.id,\r\n\t\t\tchecked: this.props.value,\r\n\t\t\tonChange: this.updateValue\r\n\t\t});\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.props.onUpdated( e.target.checked );\r\n\t},\r\n\r\n\tisType: function( value ){\r\n\t\treturn typeof value == 'boolean';\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( nextProps ){\r\n\t\tif( this.props.value != nextProps.value )\r\n\t\t\tthis.setState( { value: nextProps.value } );\r\n\t}\r\n});\r\n\r\nmodule.exports = BooleanField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/BooleanField.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/BooleanField.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tLeafMixin = __webpack_require__(18)\r\n;\r\n\r\n/**\r\n * Component for editing a number.\r\n * @param  {string} value The value of the string.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n * @param {FreezerNode} parent The parent node to let the string component update its value.\r\n */\r\nvar NumberField = React.createClass({\r\n\tmixins: [LeafMixin],\r\n\ttypeClass: 'jsonNumber',\r\n\tinputType: 'number',\r\n\tdefaultValue: '',\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\trender: function(){\r\n\t\treturn this.renderInput();\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.setState({ value: parseFloat( e.target.value ) });\r\n\t},\r\n\r\n\tisType: function( value ){\r\n\t\treturn typeof value == 'number';\r\n\t}\r\n});\r\n\r\nmodule.exports = NumberField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/NumberField.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/NumberField.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tLeafMixin = __webpack_require__(18)\r\n;\r\n\r\n/**\r\n * Component for editing a long string.\r\n * @param  {string} value The value of the string.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n * @param {FreezerNode} parent The parent node to let the string component update its value.\r\n */\r\nvar TextField = React.createClass({\r\n\tmixins: [LeafMixin],\r\n\tdefaultValue: '',\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\trender: function(){\r\n\t\tvar className = 'jsonText';\r\n\r\n\t\tif( !this.state.editing )\r\n\t\t\treturn React.DOM.span( {onClick: this.setEditMode, className: className}, this.props.value );\r\n\r\n\t\treturn React.DOM.textarea({\r\n\t\t\tvalue: this.state.value,\r\n\t\t\tid: this.props.id,\r\n\t\t\tonChange: this.updateValue,\r\n\t\t\tplaceholder: this.props.settings.placeholder || '',\r\n\t\t\tonBlur: this.setValue,\r\n\t\t\tref: 'input'\r\n\t\t});\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.setState({ value: e.target.value });\r\n\t},\r\n\r\n\tisType: function( value ){\r\n\t\treturn typeof value == 'string' && value.length > 100;\r\n\t}\r\n});\r\n\r\nmodule.exports = TextField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/TextField.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/TextField.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1),\r\n\tLeafMixin = __webpack_require__(18)\r\n;\r\n\r\n\r\n/**\r\n * Component for editing a password.\r\n * @param  {string} value The value of the password.\r\n * @param  {Mixed} original The value of the component it the original json.\r\n * @param {FreezerNode} parent The parent node to let the password component update its value.\r\n */\r\nvar PasswordField = React.createClass({\r\n\tmixins: [LeafMixin],\r\n\ttypeClass: 'jsonPassword',\r\n\tinputType: 'password',\r\n\tdefaultValue: '',\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn this.getStateFromProps( this.props );\r\n\t},\r\n\r\n\trender: function(){\r\n\t\treturn this.renderInput();\r\n\t},\r\n\r\n\tgetDisplayModeString: function(){\r\n\t\treturn this.getWildcards();\r\n\t},\r\n\r\n\tgetWildcards: function(){\r\n\t\tvar out = '';\r\n\t\tfor (var i = this.state.value.length - 1; i >= 0; i--) {\r\n\t\t\tout += '*';\r\n\t\t}\r\n\t\treturn out;\r\n\t},\r\n\r\n\tisType: function(){\r\n\t\treturn false;\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.setState({ value: e.target.value });\r\n\t}\r\n});\r\n\r\nmodule.exports = PasswordField;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/PasswordField.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/PasswordField.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(1);\r\n\r\n/**\r\n * Component for editing a boolean.\r\n * @param  {string} value The value of the boolean.\r\n */\r\nvar SelectType = React.createClass({\r\n\r\n\tdefaultValue: '',\r\n\r\n\tgetInitialState: function(){\r\n\t\treturn  {\r\n\t\t\tvalue: this.props.value\r\n\t\t};\r\n\t},\r\n\r\n\trender: function(){\r\n\t\tvar className = 'jsonSelect';\r\n\r\n\t\treturn React.DOM.select({\r\n\t\t\tclassName: className,\r\n\t\t\tid: this.props.id,\r\n\t\t\tvalue: this.props.value,\r\n\t\t\tonChange: this.updateValue\r\n\t\t}, this.renderOptions() );\r\n\t},\r\n\r\n\trenderOptions: function(){\r\n\t\tvar opts = this.props.settings.options,\r\n\t\t\toptions = []\r\n\t\t;\r\n\r\n\t\tif( !opts || !opts.length )\r\n\t\t\treturn options;\r\n\r\n\t\topts.forEach( function( opt ){\r\n\t\t\tvar data = opt;\r\n\t\t\tif( typeof opt != 'object' )\r\n\t\t\t\tdata = { value: opt, label: opt };\r\n\r\n\t\t\toptions.push(\r\n\t\t\t\tReact.DOM.option({value: data.value}, data.label)\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\treturn options;\r\n\t},\r\n\r\n\tupdateValue: function( e ){\r\n\t\tthis.props.onUpdated( e.target.value );\r\n\t},\r\n\r\n\tcomponentWillReceiveProps: function( nextProps ){\r\n\t\tif( this.props.value != nextProps.value )\r\n\t\t\tthis.setState( { value: nextProps.value } );\r\n\t}\r\n});\r\n\r\nmodule.exports = SelectType;\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types/SelectField.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/types/SelectField.js?");

/***/ }
/******/ ])
});
;